/***************************************************************** 
 * Lauro Cruz e Souza - RA: 156175                               *
 * MC202 - Turma F                                               *
 * laurocruzsouza@gmail.com / lauro.souza@students.ic.unicamp.br *
 * Laboratório 06 - Análise sintática e Árvores - analisador.c   *
 * Last modified: *
 *****************************************************************/

/* 
 * analisador.c: Módulo de transformação de expressões em Árvores
 * binárias e seus percursos.
 */

#include "analisador.h"
#include <stdlib.h>
#include <ctype.h>
#include "balloc.h"

/* Variáveis globais a este módulo */

char ant; /* Armazena o caractere da entrada anterior ao que in está apontando */

char *in;  /* Cadeia e índice para expressão infixa (entrada). */
int indIn;

Erro resCorreto = {EXPR_VALIDA,0}; /* resultado correto */

void pulaEspacoIn(); /* Pula os espaçoos em branco da infixa */
int eLetra(); /* Verifica se in[indIn] é uma letra */
int car_inv(); /* Verifica se o caractere é inválido */


/* Protótipos das funções mutuamente recursivas. */
/* O resultado é devolvido através da variável 'arv'. */
Erro Expressao(ArvBin *arv);
Erro Termo(ArvBin *arv);
Erro Fator(ArvBin *arv);
Erro Primario(ArvBin *arv);

/* Função auxiliar -- declarada mais adiante */
Erro montaErro(int codigo, int pos);


/*************************************************************/
/*                 Função   principal                        */
/*************************************************************/

Erro InArv(char *infixa, ArvBin *arv) {
/* Transforma a notação infixa em Árvore binária.  Em caso de erro,
   devolve o código e a posição na cadeia de entrada onde o erro foi
   encontrado.  */
	Erro final;

	ant = ' '; /* COmo não há anterior, inicia-se valendo ' ' */
	
	in = infixa;
	indIn = 0;
	
	if (in[0] == ' ') pulaEspacoIn();
	
	/* Não encontrando nenhum caractere na entrada, é uma cadeia de bracos */
	if (in[indIn] == '\0')
		return montaErro(CADEIA_DE_BRANCOS, 0);

	final = Expressao(arv);
	
	if ((in[indIn] != '\0') && (final.codigoErro == EXPR_VALIDA))
		return montaErro(OPERADOR_ESPERADO, indIn);
 
	return final; 

}

/*************************************************************/
/*           Funções de implementação do analisador          */
/*************************************************************/

void pulaEspacoIn() {
	if (in[indIn] != ' ') {
		ant = in[indIn];
		indIn++;
	}
	
	while (in[indIn] == ' ')
		indIn++;
}

int eLetra() {
	return ((toupper(in[indIn]) >= 'A') && (toupper(in[indIn]) <= 'Z'));
}

Erro montaErro(int codigo, int posicao) {
/* Devolve estrutura com código de erro e posição */
	Erro res;
	
	res.posicao = posicao;
	res.codigoErro = codigo;
  
	return res;

} /* montaErro */

int car_inv() {
	char c = in[indIn];
	
	return (c != '+' && c != '-' && c != '*' && c != '/' && 
			c != '^' && c != '\0'&& c != '(' && c != ')' && !eLetra());
}

Erro Expressao(ArvBin *arv) {
/* Processa uma expressão da cadeia de entrada.  */
	ArvBin noEsq = NULL, noDir = NULL;
	char op;
	Erro erroE = Termo(&noEsq);
	
	if (erroE.codigoErro != EXPR_VALIDA)
		return erroE;
	
	if (in[indIn] == '+' || in[indIn] == '-') {
		while (in[indIn] == '+' || in[indIn] == '-') {
			op = in[indIn];

			pulaEspacoIn();
			
			erroE = Termo(&noDir);
			
			if (erroE.codigoErro != EXPR_VALIDA)
				return erroE;

			*arv = MALLOC(sizeof(NoArvBin));
			(*arv)->info = op;
			(*arv)->esq = noEsq;
			(*arv)->dir = noDir;
		}
	} else *arv = noEsq;
	
	return resCorreto;
  
} /* Expressao */


Erro Termo(ArvBin *arv) {
/* Processa um termo da cadeia de entrada.  */
	ArvBin noEsq = NULL, noDir = NULL;
	char op;
	Erro erroT = Fator(&noEsq);
	
	if (erroT.codigoErro != EXPR_VALIDA)
		return erroT;
	
	
	if (in[indIn] == '*' || in[indIn] == '/') {
		while (in[indIn] == '*' || in[indIn] == '/') {
			op = in[indIn];
			
			pulaEspacoIn();
			
			erroT = Fator(&noDir);
			
			if (erroT.codigoErro != EXPR_VALIDA)
				return erroT;
			
			*arv = MALLOC(sizeof(NoArvBin));
			(*arv)->info = op;
			(*arv)->esq = noEsq;
			(*arv)->dir = noDir;
		}
	} else *arv = noEsq;
	
	return resCorreto;

} /* Termo */


Erro Fator(ArvBin *arv) {
/* Processa um fator da cadeia de entrada.  */
	ArvBin noEsq = NULL, noDir = NULL;
	Erro erroF = Primario(&noEsq);
	
	if (erroF.codigoErro != EXPR_VALIDA)
		return erroF;
	
	/* Verifica se há caractere inválido que não foi pego em Primario() */
	if (car_inv())
		return montaErro(CARACTERE_INVALIDO, indIn);
		
	if (in[indIn] == '^') {
		pulaEspacoIn();
		
		erroF = Fator(&noDir);
		
		if (erroF.codigoErro != EXPR_VALIDA)
			return erroF;
		
		*arv = MALLOC(sizeof(NoArvBin));
		(*arv)->info = '^';
		(*arv)->esq = noEsq;
		(*arv)->dir = noDir;
	} else *arv = noEsq;
  
	return resCorreto;
} /* Fator */


Erro Primario(ArvBin *arv) {
/* Processa um  primário da cadeia de entrada.  */
	Erro erroP;
	ArvBin no;
	char unr, let;
	
	if (in[indIn] == ' ') pulaEspacoIn();

	if (eLetra()) {
		let = in[indIn];
		pulaEspacoIn();
		
		/* Verifica se há dois operandos um ao lado do outro */
		if (eLetra())
			return montaErro(OPERADOR_ESPERADO, indIn);
			
		*arv = MALLOC(sizeof(NoArvBin));
		(*arv)->esq = (*arv)->dir = NULL;
		(*arv)->info = let;
		
	} else if (in[indIn] == '(') {
		pulaEspacoIn();
		/* Verifica se não hÃá operando ou operador após abrir o parêntese */
		if (in[indIn] == '\0' || in[indIn] == ')')
			return montaErro(OPERANDO_ESPERADO, indIn);
		
		erroP = Expressao(&no);
		
		if (erroP.codigoErro != EXPR_VALIDA)
			return erroP;
		
		/* Verifica de faltou o fecha parêntese */
		if (in[indIn] != ')')
			return montaErro(FECHA_PARENTESE_ESPERADO, indIn);
		
		pulaEspacoIn();
		
	/* Verifica se é operador unário */
	} else if ((in[indIn] == '+' || in[indIn] == '-') && (ant == ' ' || ant == '(')) {
		if (in[indIn] == '+') unr = '&';
		else unr = '~';
		
		pulaEspacoIn();
		/* Verifica se o operador realmente é unário ou se é binário, mas falta um operando */
		if (!eLetra() && in[indIn] != '(')
			return montaErro(OPERANDO_ESPERADO, indIn);
		erroP = Termo(&no);
		
		if (erroP.codigoErro != EXPR_VALIDA)
			return erroP;

		*arv = MALLOC(sizeof(NoArvBin));
		(*arv)->info = unr;
		(*arv)->esq = NULL;
		(*arv)->dir = no;
		
	} else if (in[indIn] == '+' || in[indIn] == '-' || in[indIn] == '*' || 
			   in[indIn] == '/' || in[indIn] == '^' || in[indIn] == ')' || 
			   in[indIn] == '\0') {
		return montaErro(OPERANDO_ESPERADO, indIn);
		
	} else return montaErro(CARACTERE_INVALIDO, indIn);
	
	return resCorreto;

} /* Primario */

/* Percursos */

void ArvPre(ArvBin arv, char *pre) {
 /* Produz a representação pré-fixa a partir da Árvore. */
	while (arv != NULL) {
		*pre = arv->info;
		pre++;
		ArvPre(arv->esq, pre);
		arv = arv->dir;
	}
	
	*pre = '\0';
}

void ArvPos(ArvBin arv, char *pos) {
/* Produz a representação pós-fixa a partir da Árvore. */  
	if (arv != NULL) {
		ArvPos(arv->esq, pos);
		ArvPos(arv->dir, pos);
		*pos = arv->info;
		pos++;
	}
	
	*pos = '\0';
}


void LiberaArv(ArvBin arv) {
/* Libera o espaço ocupado pela Árvore. */
	if (arv != NULL) {
		LiberaArv(arv->esq);
		LiberaArv(arv->dir);
		FREE(arv);
	}
}

